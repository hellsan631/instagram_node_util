// command line tool to read instagram follower counts
// based on:
// https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/

const program = require('commander');
const csv = require('csv');
const fs = require('fs');
const axios = require('axios');

// Minimum occurances count to fetch.
const minCountToFetch = 3;
// How often to write csv file.
const writeFrequency = 100;
// delay between reads
let sleepTime = 500;
// factor if timeout occurs. 1.0 means no increase in delay.
let timeoutIncreaseFactor = 1.1;

program
  .version('0.0.1')
  .option('-l, --list [list]', 'csv file with "account:count" rows')
  .option('-g, --list_generated [list_generated]', "csv file previously generated by this program")
  .option('-t, --text_output [text_output]', "output CSV file with text training data")
  .parse(process.argv)

let writeArray = [];

// headers: array of column header names
// input: array of input values
// objMerge: merge into
//
// the first value is used as key.
function _csvToObj(headers, input, objMerge) {
  let objKey = input[0];
  for (index = 1; index < input.length; index++) {
    if (index >= headers.length) {
      console.error('out of range index in headers', index, headers, input);
    }
    outputKey = headers[index];
    if (!objMerge.hasOwnProperty(objKey)) {
      objMerge[objKey] = {};
    }
    objMerge[objKey][outputKey] = input[index];
  }
}


// Reads a csv and merges accountname:count into object map.
//
// for example
// headersParam:       'count,followers'
//
// csv input row: 'tom,5,1000'
// dictMergeInto: tom: {count:5, followers:1000}
//
// filenameCsv: file/path to csv
// headersParam: comma delimited column names. if undefind, first row in csv is read for names.
// dictMergeInto: merges values into this dictionary.
// cbEndRead(data): callback after data is read.
async function readCsvAndMergeCounts(
  filenameCsv,
  headersParam,
  dictMergeInto,
  cbEndRead,
) {
  let parse = csv.parse;
  let readFirstRow = false;
  let headers = headersParam;
  // if headers is not passed in, assume first row contains column names.
  if (headers != undefined && headers != null) {
    headers = headers.split(',');
  } else {
    readFirstRow = true;
  }

  let lines_read = 0;
  // read csv and merge into object.
  fs.createReadStream(filenameCsv)
      .pipe(parse({delimiter: ','}))
      .on('data', async (csvrow) => {
        if (readFirstRow) {
          headers = csvrow;
          readFirstRow = false;
          return;
        }
        try {
          _csvToObj(headers, csvrow, dictMergeInto);
          lines_read++;
        } catch (error) {
          console.log('error _csvToObj(headers, csvrow, dictMergeInto)',
            headers, csvrow, dictMergeInto, error);
        }
      })
      .on('end', () => {
        console.log(`read csv file: ${filenameCsv}, ${lines_read} lines.`);
        cbEndRead(dictMergeInto);
      });
}

function _accountToCsv(name, count, followers, likes, engagement, comments) {
  return `${name},${count},${followers},${likes},${engagement},${comments}`;
}

// first row to emit in out csv.
const csvColumns = ['name','count','followers','likes','engagement','comments'];

async function updateMissingCounters(accountDict) {
  // Add column decriptiors to csv
  writeArray.push(csvColumns.join(','));
  writeCounter = 0;
  textBlobs = [];

  // Iterate and update records that are missing data.
  for (let name in accountDict) {
    let account = accountDict[name];
    let count = account.count;

    // Skip acounts with insufficient count, or with :cr suffix.
    if (count < minCountToFetch || name.indexOf(':cr') !== -1) {
      continue;
    }

    let fetch_success = true;

    // only refetch if data isn't present.
    if (account.followers === undefined || account.likes === undefined || isNaN(account.likes)) {
      process.stdout.write(`fetching ${name}...`);
      // Retry with backoff.
      try {
        let result = await processAccount(name);
        accountDict[name] = Object.assign(account, result);
        /*
        if (account.likes == 0) {
          // 0 means it's a private account with no media, ignore it.
          console.log('skipping', account);
        } else {
          fetch_success = false;
        }
        */
      } catch (error) {
        if (error.expectedError != true) {
          sleepTime *= timeoutIncreaseFactor;
          console.error('fetch error, increased sleep timer, skipping user',
            sleepTime, name, error);
          if (error.indexOf('ECONNRESET') != -1) {
            fetch_success = false;
          }
          await sleep(sleepTime * 2.0);
        }
        continue;
      }
      await sleep(sleepTime);
    }

    if (!fetch_success) {
      continue;
    }
    let record = _accountToCsv(
      name,
      account.count,
      account.followers,
      account.likes,
      account.engagement,
      account.comments
    );

    writeArray.push(record);
    writeCounter -= 1;

    // save textblob as well
    if (account.textBlob) {
      let csvEntry = Object.values(account.textBlob).join(',');
      // console.log('csventry:\n', csvEntry);
      textBlobs.push(csvEntry);
    }

    if (writeCounter <= 0) {
      version = writeArray.length;
      writeCsv(`./data/out${version}.csv`, writeArray.join('\n'));
      writeCounter = writeFrequency;
      if (program.text_output) {
        // also write text blobs
        writeCsv(`./data/outText${version}.csv`, textBlobs.join('\n'));
      }
    }
  }
  version = writeArray.length;
  writeCsv(`./data/out${version}_final.csv`, writeArray.join('\n'));
}

async function sleep(ms){
  return new Promise((resolve) => setTimeout(resolve, ms));
};

async function writeCsv(filename, data) {
  return await fs.writeFile(filename, data, 'utf8', function (err) {
    if (err) {
      console.log('Some error occured - file either not saved or corrupted file saved.');
    } else{
      console.log('Wrote ' + filename);
    }
  });
}

async function getFbData(username) {
  let response = undefined;
  try {
    var url = "https://www.instagram.com/" + username + "/?__a=1";
    response = await axios.get(url);
    process.stdout.write(`fetched (${response.data.user.followed_by.count})\n`);
  } catch (error) {
    let text = `getFbData axios failed for ${username}, status: ${error}`;
    console.error(text);
    let newError = new Error(text);
    newError.expectedError = true;
    throw newError;
  }
  if (response.data == undefined || response.data == null) {
    error = new Error('response.data is invalid: ' + response.data);
  }
  return response.data;
}

async function processAccount(accountName) {
  let response = {};
  response = await getFbData(accountName);
  let followers = getInstagramFollowerCount(response);
  let likes = getInstagramLikesCount(response).toFixed(0);
  let engagement = 0;
  if (followers > 0) {
    engagement = (likes / followers * 100).toFixed(2);
  }
  let comments = getInstagramCommentsCount(response).toFixed(0);
  let textBlob = undefined;
  if (program.text_output) {
    textBlob = getInstagramCaptions(response, accountName);
  }
  console.log('accountName, followers, likes)', accountName, followers, likes);
  return {followers, likes, engagement, comments, textBlob};
}


function getInstagramFollowerCount(response) {
  var count = response.user.followed_by.count;
  return Number(count);
}

function getInstagramLikesCount(response) {
  return getInstagramAveragedMediaCounts(response, 'likes');
}

function getInstagramCommentsCount(response) {
  return getInstagramAveragedMediaCounts(response, 'comments');
}

function getInstagramAveragedMediaCounts(response, type) {
  var count = 0;
  var samples = 0;
  nodes_count = response.user.media.nodes.length;
  if (nodes_count == 0) {
    return 0;
  }
  for (var i = 0; samples < 6, i + 3 < nodes_count; i++) {
    var node = response.user.media.nodes[i + 3];
    if (node == null || node.is_video) {
      continue;
    }
    count += node[type].count;
    samples += 1;
  }
  count = count / samples;

  return count;
}

function _replaceCommasOrReturnEmpty(text) {
  /*
  let encoded = encodeURI(text);
  console.log(encoded);
  return encoded;
  */

  if (text == undefined || text == null) {
    return '';
  }

  // strip commas
  const commaReplacement = 'Â¸';
  const regexComma = /,/ig;
  let result = text.replace(regexComma, commaReplacement);

  // strip linebreaks
  const linebreakRegex = /\r?\n|\r/g;
  result = result.replace(linebreakRegex, ' ');
  return result;
}

// Collects text fields including comment captions, urls, names, anything we can use
// for analysis.
function getInstagramCaptions(response, name) {
  let textBlob = {};
  let samples = 0;
  let captionNum = 0;

  textBlob.name = name;
  textBlob.followers = getInstagramFollowerCount(response);
  textBlob.biography = _replaceCommasOrReturnEmpty(response.user.biography);
  textBlob.external_url = _replaceCommasOrReturnEmpty(response.user.external_url);
  textBlob.full_name = _replaceCommasOrReturnEmpty(response.user.full_name);
  // TODO: Read and ignorep rivate accounts in original fetcher
  // TODO: Read video views. Right now account with videos only get thronw out
  // because they show 0 likes and 0 media.
  nodes_count = response.user.media.nodes.length;
  for (var i = 0; samples < 6, i < nodes_count; i++) {
    var node = response.user.media.nodes[i];
    if (node == null) {
      continue;
    }
    textBlob['caption_' + captionNum] = _replaceCommasOrReturnEmpty(node.caption);
    captionNum++;
  }

  return textBlob;
}

function testcsvToObj() {
  let headers = 'name,count,followers';
  let row = 'tom,5,1000';
  // initial dict contains only count not followers, should be overwritten.
  let dict = {tom: {count:3} };
  _csvToObj(headers.split(','), row.split(','), dict);
  let expected = { tom: { count: '5', followers: '1000' } };
  console.info(
    'expected/actual test output:\n',
    expected,
    '\n',
    dict);
}

// Main.
async function main() {
  testcsvToObj();

  let dictCounts = {};
  // Read the raw counst table first, output from crawler
  const columnNames = 'name,count';
  await readCsvAndMergeCounts(
    program.list,
    columnNames,
    dictCounts,
    async (data) => {
        // If present, read the previous output from here.
        if (program.list_generated) {
          await readCsvAndMergeCounts(
            program.list_generated,
            null,
            dictCounts,
            updateMissingCounters);
        } else {
          await updateMissingCounters(dictCounts);
        }
    });


  console.log('done csv');
}
main();