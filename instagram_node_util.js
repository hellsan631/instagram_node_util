// command line tool to read instagram follower counts
// based on:
// https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/

const program = require('commander');
const csv = require('csv');
const fs = require('fs');
const axios = require('axios');

// Minimum occurances count to fetch.
const minCountToFetch = 2;
// minimu follower threshold for text output exports.
const textOutputFetchMinimumFollowers = 1700;
// How often to write csv file.
const writeFrequency = 400;
// delay between reads
let sleepTime = 500;
// factor if timeout occurs. 1.0 means no increase in delay.
let timeoutIncreaseFactor = 1.1;

let fetchedUsers = 0;
let errorUsers = 0;
let skippedUsers = 0;

program
  .version('0.0.1')
  .option('-l, --list [list]', 'csv file with "account:count" rows')
  .option('-g, --list_generated [list_generated]', "csv file previously generated by this program")
  .option('-t, --text_output [text_output]', "output CSV file with text training data")
  .parse(process.argv)

let writeArray = [];

// headers: array of column header names
// input: array of input values
// objMerge: merge into
//
// the first value is used as key.
function _csvToObj(headers, input, objMerge) {
  let objKey = input[0];
  for (index = 1; index < input.length; index++) {
    if (index >= headers.length) {
      console.error('out of range index in headers', index, headers, input);
    }
    outputKey = headers[index];
    if (!objMerge.hasOwnProperty(objKey)) {
      objMerge[objKey] = {};
    }
    objMerge[objKey][outputKey] = input[index];
  }
}


// Reads a csv and merges accountname:count into object map.
//
// for example
// headersParam:       'count,followers'
//
// csv input row: 'tom,5,1000'
// dictMergeInto: tom: {count:5, followers:1000}
//
// filenameCsv: file/path to csv
// headersParam: comma delimited column names. if undefind, first row in csv is read for names.
// dictMergeInto: merges values into this dictionary.
// cbEndRead(data): callback after data is read.
async function readCsvAndMergeCounts(
  filenameCsv,
  headersParam,
  dictMergeInto,
  cbEndRead,
) {
  let parse = csv.parse;
  let readFirstRow = false;
  let headers = headersParam;
  // if headers is not passed in, assume first row contains column names.
  if (headers != undefined && headers != null) {
    headers = headers.split(',');
  } else {
    readFirstRow = true;
  }

  let lines_read = 0;
  // read csv and merge into object.
  fs.createReadStream(filenameCsv)
      .pipe(parse({delimiter: ','}))
      .on('data', async (csvrow) => {
        if (readFirstRow) {
          headers = csvrow;
          readFirstRow = false;
          return;
        }
        try {
          _csvToObj(headers, csvrow, dictMergeInto);
          lines_read++;
        } catch (error) {
          console.log('error _csvToObj(headers, csvrow, dictMergeInto)',
            headers, csvrow, dictMergeInto, error);
        }
      })
      .on('end', () => {
        console.log(`read csv file: ${filenameCsv}, ${lines_read} lines.`);
        cbEndRead(dictMergeInto);
      });
}

function _accountToCsv(name, count, followers, likes, engagement, comments) {
  return `${name},${count},${followers},${likes},${engagement},${comments}`;
}

// first row to emit in out csv.
const csvColumns = ['name','count','followers','likes','engagement','comments'];

// Creater dir, if it does not exist.
function createDirIfNotExists(dirName) {
  if (!fs.existsSync(dirName)){
    fs.mkdirSync(dirName);
    console.info(`created directory: ${dirName}.`);
  }
}

// Fetches user with retry. If it's a permanent error like 404, returns false.
// If it's a temp error like connection problem, retries infinitely.
async function fetchDataWithRetry(name, account) {
  // Retry with backoff.
  let retryConnect = true;
  let fetchedData = false;
  let retryDelay = sleepTime;
  while (retryConnect) {
    try {
      retryConnect = false;
      let result = await processAccount(name);
      account = Object.assign(account, result);
      fetchedUsers += 1;
      fetchedData = true;
    } catch (error) {
      errorUsers += 1;

      // 429 is too many connections, increase timeout.
      if (error.status == '429') {
        sleepTime *= timeoutIncreaseFactor;
        console.error('fetch error, increasing delay, retrying. ',
          error.code, error.status, sleepTime, name, error);
        retryConnect = true;
        sleepTime += 200;
        await sleep(sleepTime * 2.0);
      } else {
        // Connection problems not related to throttling.
        switch(error.code) {
          case 'ENOTFOUND': // internet died
          case 'ECONNRESET': // internet connection died
          case 'ECONNABORTED': // timeout
            retryConnect = true;
            console.warn('connection problem, retrying with backoff..');
            retryDelay *= 2.0;
            retryDelay = Math.min(retryDelay, 120*1000);
            break;
          // other problem not related to connection, ie 404,
          default:
            console.error('unknown error, skipping user', error);
            break;
        }
      }
    }
    await sleep(retryDelay);
  }
  return fetchedData;
}

async function updateMissingCounters(accountDict) {
  createDirIfNotExists(`./data`);

  // Add column decriptiors to csv
  writeArray.push(csvColumns.join(','));
  writeCounter = 0;
  textBlobs = [];

  // Iterate and update records that are missing data.
  for (let name in accountDict) {
    let account = accountDict[name];
    let count = account.count;

    // Skip acounts with insufficient count, or with :cr suffix.
    if (count < minCountToFetch || name.indexOf(':cr') !== -1) {
      skippedUsers++;
      continue;
    }

    // if we're exporting text, set a follower threshold.
    if (program.text_output &&
      (!account.followers || account.followers < textOutputFetchMinimumFollowers)) {
        console.log('skipping text_output: ', name, account.followers);
      skippedUsers++;
      continue;
    }

    // Request fetching textual data.
    const needFetchTextData = (program.text_output && account.textBlob == undefined);
    // only refetch if data isn't present.
    let shouldSaveData = true;
    if (account.followers === undefined ||
        account.likes === undefined ||
        account.comments === undefined ||
        account.comments == 'undefined' ||
        isNaN(account.likes) ||
        needFetchTextData) {
      process.stdout.write(`fetching ${name}...`);
      shouldSaveData = await fetchDataWithRetry(name, account);
    }

    if (!shouldSaveData) {
      continue;
    }

    let record = _accountToCsv(
      name,
      account.count,
      account.followers,
      account.likes,
      account.engagement,
      account.comments
    );

    writeArray.push(record);
    writeCounter -= 1;

    // save textblob as well
    if (account.textBlob) {
      // For first row, add the column names.
      if (textBlobs.length == 0) {
        textBlobs.push(Object.keys(account.textBlob).join(','));
      }
      let csvEntry = Object.values(account.textBlob).join(',');
      // console.log('csventry:\n', csvEntry);
      textBlobs.push(csvEntry);
    }

    if (writeCounter <= 0) {
      version = writeArray.length;
      writeCsv(`./data/out${version}.csv`, writeArray.join('\n'));
      writeCounter = writeFrequency;
      if (program.text_output) {
        // also write text blobs
        writeCsv(`./data/outText${version}.csv`, textBlobs.join('\n'));
      }
    }
  }
  version = writeArray.length;
  writeCsv(`./data/out${version}_final.csv`, writeArray.join('\n'));
  console.log(`complete. fetched ${fetchedUsers} users, ${errorUsers} errors.`)
}

async function sleep(ms){
  return new Promise((resolve) => setTimeout(resolve, ms));
};

async function writeCsv(filename, data) {
  return await fs.writeFile(filename, data, 'utf8', function (err) {
    if (err) {
      console.log('Some error occured - file either not saved or corrupted file saved.');
    } else{
      console.log('Wrote ', filename, fetchedUsers);
    }
  });
}

async function getFbData(username) {
  let response = undefined;
  try {
    var url = "https://www.instagram.com/" + username + "/?__a=1";
    response = await axios.get(url, {
      timeout: 2500
    });
    process.stdout.write(`fetched (${fetchedUsers})\n`);
  } catch (error) {
    let status = 'not_available';
    if (error.response) {
      status = error.response.status;
    }
    let text = `getFbData axios failed: ${username}, (${error}) code:${error.code} status:${status}`;
    console.error(text);
    let newError = new Error(text);
    newError.code = error.code; // connection error code, like 'ECONNABORTED' etc.
    newError.stuats = status;
    throw newError;
  }
  if (response.data == undefined || response.data == null) {
    error = new Error('response.data is invalid:' + response.data);
  }
  return response.data;
}

async function processAccount(accountName) {
  let response = {};
  response = await getFbData(accountName);
  let followers = getInstagramFollowerCount(response);
  let likes = getInstagramLikesCount(response).toFixed(0);
  let engagement = 0;
  if (followers > 0) {
    engagement = (likes / followers * 100).toFixed(2);
  }
  let comments = getInstagramCommentsCount(response).toFixed(0);
  let textBlob = undefined;
  if (program.text_output) {
    textBlob = getInstagramCaptions(response, accountName);
  }
  return {followers, likes, engagement, comments, textBlob};
}


function getInstagramFollowerCount(response) {
  var count = response.user.followed_by.count;
  return Number(count);
}

function getInstagramLikesCount(response) {
  return getMedianMediaCounts(response, 'likes');
}

function getInstagramCommentsCount(response) {
  return getMedianMediaCounts(response, 'comments');
}

// Compute median of array of values.
function median(values) {
  values.sort( function(a,b) {return a - b;} );
  var half = Math.floor(values.length/2);
  if(values.length % 2)
      return values[half];
  else
      return (values[half-1] + values[half]) / 2.0;
}

function getMedianMediaCounts(response, type) {
  let counts = [];
  nodes_count = response.user.media.nodes.length;
  if (nodes_count == 0) {
    return 0;
  }
  for (var i = 0; i + 3 < nodes_count; i++) {
    var node = response.user.media.nodes[i + 3];
    if (node == null || node.is_video) {
      continue;
    }
    counts.push(node[type].count);
  }
  return median(counts);
}

function _replaceCommasOrReturnEmpty(text) {
  /*
  let encoded = encodeURI(text);
  console.log(encoded);
  return encoded;
  */

  if (text == undefined || text == null) {
    return '';
  }

  // strip commas
  const commaReplacement = '¸';
  const regexComma = /,/ig;
  let result = text.replace(regexComma, commaReplacement);

  // strip linebreaks
  const linebreakRegex = /\r?\n|\r/g;
  result = result.replace(linebreakRegex, ' ');
  return result;
}

// Collects text fields including comment captions, urls, names, anything we can use
// for analysis.
function getInstagramCaptions(response, name) {
  let textBlob = {};
  let samples = 0;
  let captionNum = 0;

  textBlob.name = name;
  textBlob.followers = getInstagramFollowerCount(response);
  textBlob.biography = _replaceCommasOrReturnEmpty(response.user.biography);
  textBlob.external_url = _replaceCommasOrReturnEmpty(response.user.external_url);
  textBlob.full_name = _replaceCommasOrReturnEmpty(response.user.full_name);
  textBlob.profile_pic_url_hd = _replaceCommasOrReturnEmpty(response.user.profile_pic_url_hd);
  textBlob.profile_pic_url = _replaceCommasOrReturnEmpty(response.user.profile_pic_url);
  // TODO: Read and ignore private accounts in original fetcher
  // TODO: Read video views. Right now account with videos only get thronw out
  // because they show 0 likes and 0 media.
  nodes_count = response.user.media.nodes.length;
  for (var i = 0; samples < 6, i < nodes_count; i++) {
    var node = response.user.media.nodes[i];
    if (node == null) {
      continue;
    }
    textBlob['caption_' + captionNum] = _replaceCommasOrReturnEmpty(node.caption);
    captionNum++;
  }

  return textBlob;
}

function testcsvToObj() {
  let headers = 'name,count,followers';
  let row = 'tom,5,1000';
  // initial dict contains only count not followers, should be overwritten.
  let dict = {tom: {count:3} };
  _csvToObj(headers.split(','), row.split(','), dict);
  let expected = { tom: { count: '5', followers: '1000' } };
  console.info(
    'expected/actual test output:\n',
    expected,
    '\n',
    dict);
}

// Main.
async function main() {
  testcsvToObj();

  let dictCounts = {};
  // Read the raw counst table first, output from crawler
  const columnNames = 'name,count';
  await readCsvAndMergeCounts(
    program.list,
    columnNames,
    dictCounts,
    async (data) => {
        // If present, read the previous output from here.
        if (program.list_generated) {
          await readCsvAndMergeCounts(
            program.list_generated,
            null,
            dictCounts,
            updateMissingCounters);
        } else {
          await updateMissingCounters(dictCounts);
        }
    });


  console.log('done csv');
}
main();