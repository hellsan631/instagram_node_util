// command line tool to read instagram follower counts
// based on:
// https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/

const program = require('commander');
const csv = require('csv');
const fs = require('fs');
const axios = require('axios');

// Minimum occurances count to fetch.
const minCountToFetch = 2;
// How often to write csv file.
const writeFrequency = 50;
// delay between reads
let sleepTime = 500;
// factor if timeout occurs. 1.0 means no increase in delay.
let timeoutIncreaseFactor = 1.1;

program
  .version('0.0.1')
  .option('-l, --list [list]', 'csv file with "account:count" rows')
  .option('-g, --list_generated [list_generated]', "csv file previously generated by this program'")
  .parse(process.argv)

let writeArray = [];

// headers: array of column header names
// input: array of input values
// objMerge: merge into
//
// the first value is used as key.
function _csvToObj(headers, input, objMerge) {
  let objKey = input[0];
  for (index = 1; index < input.length; index++) {
    if (index >= headers.length) {
      console.error('out of range index in headers', index, headers, input);
    }
    outputKey = headers[index];
    if (!objMerge.hasOwnProperty(objKey)) {
      objMerge[objKey] = {};
    }
    objMerge[objKey][outputKey] = input[index];
  }
}


// Reads a csv and merges accountname:count into object map.
//
// for example
// headersParam:       'count,followers'
//
// csv input row: 'tom,5,1000'
// dictMergeInto: tom: {count:5, followers:1000}
//
// filenameCsv: file/path to csv
// headersParam: comma delimited column names. if undefind, first row in csv is read for names.
// dictMergeInto: merges values into this dictionary.
// cbEndRead(data): callback after data is read.
async function readCsvAndMergeCounts(
  filenameCsv,
  headersParam,
  dictMergeInto,
  cbEndRead,
) {
  let parse = csv.parse;
  let readFirstRow = false;
  let headers = headersParam;
  // if headers is not passed in, assume first row contains column names.
  if (headers != undefined && headers != null) {
    headers = headers.split(',');
  } else {
    readFirstRow = true;
  }
  // read csv and merge into object.
  fs.createReadStream(filenameCsv)
      .pipe(parse({delimiter: ','}))
      .on('data', async (csvrow) => {
        if (readFirstRow) {
          headers = csvrow;
          readFirstRow = false;
          return;
        }
        try {
          _csvToObj(headers, csvrow, dictMergeInto);
        } catch (error) {
          console.log('error _csvToObj(headers, csvrow, dictMergeInto)',
            headers, csvrow, dictMergeInto, error);
        }
      })
      .on('end', () => {
        cbEndRead(dictMergeInto);
      });
}

function _accountToCsv(name, count, followers, likes, engagement, comments) {
  return `${name},${count},${followers},${likes},${engagement}%,${comments}`;
}

// first row to emit in out csv.
const csvColumns = ['name','count','followers','likes','engagement','comments'];

async function updateMissingCounters(accountDict) {
  // Add column decriptiors to csv
  writeArray.push(csvColumns.join(','));
  writeCounter = 0;

  // Iterate and update records that are missing data.
  for (let name in accountDict) {
    let account = accountDict[name];
    let count = account.count;

    // Skip acounts with insufficient count, or with :cr suffix.
    if (count < minCountToFetch || name.indexOf(':cr') !== -1) {
      continue;
    }

    // only refetch if data isn't present.
    if ((account.followers === undefined || account.likes === undefined)) {
      process.stdout.write(`fetching ${name}...`);
      let fetch_success = false;
      // Retry with backoff.
      while (!fetch_success) {
        try {
          let result = await processAccount(name);
          accountDict[name] = Object.assign(account, result);
          fetch_success = true;
        } catch (error) {
          if (error.expectedError != true) {
            sleepTime *= timeoutIncreaseFactor;
            console.error('fetch error, increased sleep timer, skipping user',
              sleepTime, name, error);
            await sleep(sleepTime * 2.0);
          }
          fetch_success = true; // skip, don't keep retrying and get stuck.
        }
      }
      await sleep(sleepTime);
    } else {
      // process.stdout.write(`not fetching ${name}, already hve data...\n`);
    }

    let record = _accountToCsv(
      name,
      account.count,
      account.followers,
      account.likes,
      account.engagement,
      account.comments
    );

    writeArray.push(record);
    writeCounter -= 1;
    if (writeCounter <= 0) {
      version = writeArray.length;
      writeCsv(`./data/out${version}.csv`, writeArray.join('\n'));
      writeCounter = writeFrequency;
    }
  }
  writeCsv(`./data/out${version}.csv`, writeArray.join('\n'));
}

async function sleep(ms){
  return new Promise((resolve) => setTimeout(resolve, ms));
};

async function writeCsv(filename, data) {
  return await fs.writeFile(filename, data, 'utf8', function (err) {
    if (err) {
      console.log('Some error occured - file either not saved or corrupted file saved.');
    } else{
      console.log('Wrote ' + filename);
    }
  });
}

async function getFbData(username) {
  let response = undefined;
  try {
    var url = "https://www.instagram.com/" + username + "/?__a=1";
    response = await axios.get(url);
    process.stdout.write(`fetched (${response.data.user.followed_by.count})\n`);
  } catch (error) {
    let text = `getFbData axios failed for ${username}, status: ${error.response.statusText}`;
    console.error(text);
    let newError = new Error(text);
    newError.expectedError = true;
    throw newError;
  }
  if (response.data == undefined || response.data == null) {
    error = new Error('response.data is invalid: ' + response.data);
  }
  return response.data;
}

async function processAccount(accountName) {
  let response = {};
  response = await getFbData(accountName);
  let followers = getInstagramFollowerCount(response);
  let likes = getInstagramLikesCount(response).toFixed(0);
  let engagement = (likes / followers * 100).toFixed(2);
  let comments = getInstagramCommentsCount(response).toFixed(0);
  return {followers, likes, engagement, comments};
}


function getInstagramFollowerCount(response) {
  var count = response.user.followed_by.count;
  return Number(count);
}

function getInstagramLikesCount(response) {
  return getInstagramAveragedMediaCounts(response, 'likes');
}

function getInstagramCommentsCount(response) {
  return getInstagramAveragedMediaCounts(response, 'comments');
}

function getInstagramAveragedMediaCounts(response, type) {
  var count = 0;
  var samples = 0;
  nodes_count = response.user.media.nodes.length;
  for (var i = 0; samples < 6, i + 3 < nodes_count; i++) {
    var node = response.user.media.nodes[i + 3];
    if (node == null || node.is_video) {
      continue;
    }
    count += node[type].count;
    samples += 1;
  }
  count = count / samples;

  return count;
}


function testcsvToObj() {
  let headers = 'name,count,followers';
  let row = 'tom,5,1000';
  // initial dict contains only count not followers, should be overwritten.
  let dict = {tom: {count:3} };
  _csvToObj(headers.split(','), row.split(','), dict);
  let expected = { tom: { count: '5', followers: '1000' } };
  console.log(
    'expected/actual test output:\n',
    expected,
    '\n',
    dict);
}
// Main.
async function main() {
  testcsvToObj();

  let dictCounts = {};
  // Read the raw counst table first, output from crawler
  const columnNames = 'name,count';
  await readCsvAndMergeCounts(
    program.list,
    columnNames,
    dictCounts,
    async (data) => {
        // If present, read the previous output from here.
        if (program.list_generated) {
          await readCsvAndMergeCounts(
            program.list_generated,
            null,
            dictCounts,
            updateMissingCounters);
        } else {
          await updateMissingCounters(dictCounts);
        }
    });


  console.log('done csv');
}
main();